#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: NinjaLiveFunctions

#include "Basic.hpp"

#include "NinjaLiveFunctions_classes.hpp"
#include "NinjaLiveFunctions_parameters.hpp"


namespace SDK
{

// Function NinjaLiveFunctions.NinjaLiveFunctions_C.TraceOverlapSingle
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Start                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TracelineOvershoot                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              TraceMesh                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor*                    HitUV                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         TracePosition                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UNinjaLiveFunctions_C::TraceOverlapSingle(const struct FVector& Start, const struct FVector& End, float TracelineOvershoot, class UPrimitiveComponent* TraceMesh, class UObject* __WorldContext, struct FLinearColor* HitUV, struct FVector* TracePosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NinjaLiveFunctions_C", "TraceOverlapSingle");

	Params::NinjaLiveFunctions_C_TraceOverlapSingle Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.TracelineOvershoot = TracelineOvershoot;
	Parms.TraceMesh = TraceMesh;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (HitUV != nullptr)
		*HitUV = std::move(Parms.HitUV);

	if (TracePosition != nullptr)
		*TracePosition = std::move(Parms.TracePosition);
}


// Function NinjaLiveFunctions.NinjaLiveFunctions_C.CameraFacing
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  InMesh                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseLegacyFacing                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    LockY                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FRotator&                  TraceMeshInitRot                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UNinjaLiveFunctions_C::CameraFacing(class USceneComponent* InMesh, bool UseLegacyFacing, bool LockY, const struct FRotator& TraceMeshInitRot, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NinjaLiveFunctions_C", "CameraFacing");

	Params::NinjaLiveFunctions_C_CameraFacing Parms{};

	Parms.InMesh = InMesh;
	Parms.UseLegacyFacing = UseLegacyFacing;
	Parms.LockY = LockY;
	Parms.TraceMeshInitRot = std::move(TraceMeshInitRot);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function NinjaLiveFunctions.NinjaLiveFunctions_C.RenderTgAcquisitionStatus
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    SelfRef                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RT_number___added                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ESimPrecision_Enum                      SimPrecision                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ResX                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ResY                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    PoolManDetected                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    HalfRes                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   NumberOfChannels                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Print                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// float*                                  MemConsumtion                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UNinjaLiveFunctions_C::RenderTgAcquisitionStatus(const class UObject* SelfRef, int32 RT_number___added, ESimPrecision_Enum SimPrecision, int32 ResX, int32 ResY, bool PoolManDetected, bool HalfRes, int32 NumberOfChannels, class UObject* __WorldContext, class FString* Print, float* MemConsumtion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NinjaLiveFunctions_C", "RenderTgAcquisitionStatus");

	Params::NinjaLiveFunctions_C_RenderTgAcquisitionStatus Parms{};

	Parms.SelfRef = SelfRef;
	Parms.RT_number___added = RT_number___added;
	Parms.SimPrecision = SimPrecision;
	Parms.ResX = ResX;
	Parms.ResY = ResY;
	Parms.PoolManDetected = PoolManDetected;
	Parms.HalfRes = HalfRes;
	Parms.NumberOfChannels = NumberOfChannels;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Print != nullptr)
		*Print = std::move(Parms.Print);

	if (MemConsumtion != nullptr)
		*MemConsumtion = Parms.MemConsumtion;
}


// Function NinjaLiveFunctions.NinjaLiveFunctions_C.AcquireRenderTargetsFromPool
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Request_0isRGBA1isRG2isR                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Host_RenderTG_List_Index                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>&                  RenderTargetList                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<class FString, class UTextureRenderTarget2D*>*RenderTargetsMapTmp                                    (Parm, OutParm)

void UNinjaLiveFunctions_C::AcquireRenderTargetsFromPool(int32 Request_0isRGBA1isRG2isR, int32 Host_RenderTG_List_Index, TArray<class FString>& RenderTargetList, class UObject* __WorldContext, TMap<class FString, class UTextureRenderTarget2D*>* RenderTargetsMapTmp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NinjaLiveFunctions_C", "AcquireRenderTargetsFromPool");

	Params::NinjaLiveFunctions_C_AcquireRenderTargetsFromPool Parms{};

	Parms.Request_0isRGBA1isRG2isR = Request_0isRGBA1isRG2isR;
	Parms.Host_RenderTG_List_Index = Host_RenderTG_List_Index;
	Parms.RenderTargetList = std::move(RenderTargetList);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	RenderTargetList = std::move(Parms.RenderTargetList);

	if (RenderTargetsMapTmp != nullptr)
		*RenderTargetsMapTmp = std::move(Parms.RenderTargetsMapTmp);
}


// Function NinjaLiveFunctions.NinjaLiveFunctions_C.TemplateLoader
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             TemplateDefinition                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UDataTable*                       LoadedDataTable                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class FString&                    LoadedDatatablePath                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   LoadFailed                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject**                         LoadedTemplateObject                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          LoadedTmpFullPath                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          LoadedTemplateNameOnly                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   UsesAbsolutePath                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UNinjaLiveFunctions_C::TemplateLoader(class FName TemplateDefinition, class UDataTable* LoadedDataTable, const class FString& LoadedDatatablePath, class UObject* __WorldContext, bool* LoadFailed, class UObject** LoadedTemplateObject, class FString* LoadedTmpFullPath, class FString* LoadedTemplateNameOnly, bool* UsesAbsolutePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NinjaLiveFunctions_C", "TemplateLoader");

	Params::NinjaLiveFunctions_C_TemplateLoader Parms{};

	Parms.TemplateDefinition = TemplateDefinition;
	Parms.LoadedDataTable = LoadedDataTable;
	Parms.LoadedDatatablePath = std::move(LoadedDatatablePath);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (LoadFailed != nullptr)
		*LoadFailed = Parms.LoadFailed;

	if (LoadedTemplateObject != nullptr)
		*LoadedTemplateObject = Parms.LoadedTemplateObject;

	if (LoadedTmpFullPath != nullptr)
		*LoadedTmpFullPath = std::move(Parms.LoadedTmpFullPath);

	if (LoadedTemplateNameOnly != nullptr)
		*LoadedTemplateNameOnly = std::move(Parms.LoadedTemplateNameOnly);

	if (UsesAbsolutePath != nullptr)
		*UsesAbsolutePath = Parms.UsesAbsolutePath;
}


// Function NinjaLiveFunctions.NinjaLiveFunctions_C.SingleKeyPicker
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDataTable*                       DataTableIn                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class FString&                    KeyToPick                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          PickedKeyValue                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   NotFound                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UNinjaLiveFunctions_C::SingleKeyPicker(class UDataTable* DataTableIn, const class FString& KeyToPick, class UObject* __WorldContext, class FString* PickedKeyValue, bool* NotFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NinjaLiveFunctions_C", "SingleKeyPicker");

	Params::NinjaLiveFunctions_C_SingleKeyPicker Parms{};

	Parms.DataTableIn = DataTableIn;
	Parms.KeyToPick = std::move(KeyToPick);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (PickedKeyValue != nullptr)
		*PickedKeyValue = std::move(Parms.PickedKeyValue);

	if (NotFound != nullptr)
		*NotFound = Parms.NotFound;
}


// Function NinjaLiveFunctions.NinjaLiveFunctions_C.CreateRenderTarget
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Width                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Height                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ETextureRenderTargetFormat              Format                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Clamping                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// ETextureGroup                           LODgroup                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ETextureFilter                          Filter                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTextureRenderTarget2D**          RTout                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UNinjaLiveFunctions_C::CreateRenderTarget(int32 Width, int32 Height, ETextureRenderTargetFormat Format, bool Clamping, ETextureGroup LODgroup, ETextureFilter Filter, class UObject* __WorldContext, class UTextureRenderTarget2D** RTout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NinjaLiveFunctions_C", "CreateRenderTarget");

	Params::NinjaLiveFunctions_C_CreateRenderTarget Parms{};

	Parms.Width = Width;
	Parms.Height = Height;
	Parms.Format = Format;
	Parms.Clamping = Clamping;
	Parms.LODgroup = LODgroup;
	Parms.Filter = Filter;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (RTout != nullptr)
		*RTout = Parms.RTout;
}


// Function NinjaLiveFunctions.NinjaLiveFunctions_C.PresetLoader
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    PresetName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// TArray<class FName>&                    AssetPath                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName                             AssetTrimmedName                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ForcePreferredPreset                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UDataTable*                       PreferredPreset                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UDataTable**                      LoadedDataTable                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          LoadedDataTablePath                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// TMap<class FString, float>*             PresetMap                                              (Parm, OutParm)

void UNinjaLiveFunctions_C::PresetLoader(const class FString& PresetName, TArray<class FName>& AssetPath, class FName AssetTrimmedName, bool ForcePreferredPreset, class UDataTable* PreferredPreset, class UObject* __WorldContext, class UDataTable** LoadedDataTable, class FString* LoadedDataTablePath, TMap<class FString, float>* PresetMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NinjaLiveFunctions_C", "PresetLoader");

	Params::NinjaLiveFunctions_C_PresetLoader Parms{};

	Parms.PresetName = std::move(PresetName);
	Parms.AssetPath = std::move(AssetPath);
	Parms.AssetTrimmedName = AssetTrimmedName;
	Parms.ForcePreferredPreset = ForcePreferredPreset;
	Parms.PreferredPreset = PreferredPreset;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	AssetPath = std::move(Parms.AssetPath);

	if (LoadedDataTable != nullptr)
		*LoadedDataTable = Parms.LoadedDataTable;

	if (LoadedDataTablePath != nullptr)
		*LoadedDataTablePath = std::move(Parms.LoadedDataTablePath);

	if (PresetMap != nullptr)
		*PresetMap = std::move(Parms.PresetMap);
}


// Function NinjaLiveFunctions.NinjaLiveFunctions_C.TraceOverlap
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Start                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TracelineOvershoot                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ETraceTypeQuery                         TraceChannel                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>&                  FluidNinjaLIVEActors                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor*                    HitUV                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         TracePosition                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UNinjaLiveFunctions_C::TraceOverlap(const struct FVector& Start, const struct FVector& End, float TracelineOvershoot, ETraceTypeQuery TraceChannel, TArray<class AActor*>& FluidNinjaLIVEActors, class UObject* __WorldContext, struct FLinearColor* HitUV, struct FVector* TracePosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NinjaLiveFunctions_C", "TraceOverlap");

	Params::NinjaLiveFunctions_C_TraceOverlap Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.TracelineOvershoot = TracelineOvershoot;
	Parms.TraceChannel = TraceChannel;
	Parms.FluidNinjaLIVEActors = std::move(FluidNinjaLIVEActors);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	FluidNinjaLIVEActors = std::move(Parms.FluidNinjaLIVEActors);

	if (HitUV != nullptr)
		*HitUV = std::move(Parms.HitUV);

	if (TracePosition != nullptr)
		*TracePosition = std::move(Parms.TracePosition);
}


// Function NinjaLiveFunctions.NinjaLiveFunctions_C.TraceMouse
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          HitComponent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TouchSensitive                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// uint8                                   FingerIndex                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ETraceTypeQuery                         TraceChannel                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TArray<class AActor*>&            FluidNinjaLIVEActors                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor*                    HitUV                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   SimHitByMouse                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   MouseClickValid                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   TouchValid                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UNinjaLiveFunctions_C::TraceMouse(class UObject* HitComponent, bool TouchSensitive, uint8 FingerIndex, ETraceTypeQuery TraceChannel, const TArray<class AActor*>& FluidNinjaLIVEActors, class UObject* __WorldContext, struct FLinearColor* HitUV, bool* SimHitByMouse, bool* MouseClickValid, bool* TouchValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NinjaLiveFunctions_C", "TraceMouse");

	Params::NinjaLiveFunctions_C_TraceMouse Parms{};

	Parms.HitComponent = HitComponent;
	Parms.TouchSensitive = TouchSensitive;
	Parms.FingerIndex = FingerIndex;
	Parms.TraceChannel = TraceChannel;
	Parms.FluidNinjaLIVEActors = std::move(FluidNinjaLIVEActors);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (HitUV != nullptr)
		*HitUV = std::move(Parms.HitUV);

	if (SimHitByMouse != nullptr)
		*SimHitByMouse = Parms.SimHitByMouse;

	if (MouseClickValid != nullptr)
		*MouseClickValid = Parms.MouseClickValid;

	if (TouchValid != nullptr)
		*TouchValid = Parms.TouchValid;
}

}

